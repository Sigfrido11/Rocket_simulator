#ifndef ENGINE_H
#define ENGINE_H

#include <cmath>
#include "vector_math.h"

namespace engine {

// ============================================================================
// ABSTRACT BASE CLASS: Engine
// ============================================================================
// This defines the interface for any propulsion system used in the simulation.
// All derived engines (simple, solid, liquid) must implement these methods.
//
class Engine {
public:

    // Computes the mass variation over a time interval.
    // time         -> time step [s]
    // is_orbiting  -> whether vehicle is in orbital phase 
    virtual double delta_m(double time, bool is_orbiting) const = 0;

    // Computes the thrust force vector generated by the engine.
    // par          -> operational parameters (direction, exit pressure, etc.)
    // is_orbiting  -> state flag
    virtual Vec eng_force(double pa, double pe, double theta,
                          bool is_orbiting) const = 0;

    // Activates the engine (ignition event).
    virtual void release() = 0;

    // Returns true if engine uses advanced thermodynamic model.
    virtual bool is_ad_eng() const = 0;

    // Returns true if engine uses liquid propellant.
    virtual bool is_liquid() const = 0;

    // Returns true if engine has been ignited.
    virtual bool is_released() const = 0;

    // Returns chamber pressure [Pa].
    virtual double get_pression() const = 0;

    virtual ~Engine() = default;
};



// ============================================================================
// BASE ENGINE (Simplified Isp-based model)
// ============================================================================
// This is a reduced-order propulsion model.
// Thrust and mass flow are approximated using constant Isp and empirical
// mass consumption coefficient.
//
class Base_engine final : public Engine {

    double isp_{350.0};     // Specific impulse [s]
    double cm_{4.0};        // Mass loss coefficient [kg/s]
    double p_0_{5e6};       // Nominal chamber pressure [Pa]
    double burn_a_{};   
    bool released_{false};  // Ignition flag

public:
    Base_engine() = default;
    Base_engine(double isp, double cm, double p0, double burn_a);

    double delta_m(double time, bool is_orbiting) const override;

    Vec eng_force(double pa, double pe, double theta,
                  bool is_orbiting) const override;

    void release() override;

    bool is_ad_eng() const override;
    bool is_liquid() const override;

    bool is_released() const override;

    double get_pression() const override;
};



// ============================================================================
// ADVANCED SOLID ROCKET ENGINE
// ============================================================================
// High-fidelity solid propulsion model including:
// - Pressure-dependent regression law
// - Propellant mass generation
// - Isentropic nozzle expansion
//
class Ad_sol_engine final : public Engine {

    // Thermodynamic chamber state
    double p_c_{7.0e6};     // Chamber pressure [Pa]
    double T_c_{3400.0};    // Chamber temperature [K]
    double gamma_{1.22};    // Heat capacity ratio of exhaust gases
    double M_{0.023};       // Effective molar mass [kg/mol]

    // Geometric properties
    double A_b_{40.0};      // Burning surface area [m^2]
    double A_t_{1.0};       // Nozzle throat area [m^2]
    double A_e_{7.0};       // Nozzle exit area [m^2]

    // Propellant properties
    double rho_p_{1800.0};  // Propellant density [kg/m^3]
    double a_{5e-5};        // Burn rate coefficient
    double n_{0.35};        // Pressure exponent

    bool released_{false};  // released flag
    bool liquid_{false};    // propellant flag true if liquid

public:
    Ad_sol_engine() = default;
    Ad_sol_engine(double p_c,
                  double T_c,
                  double A_b,
                  double A_t,
                  double rho_p,
                  double a,
                  double n,
                  double M);

    double delta_m(double time, bool is_orbiting) const override;

    Vec eng_force(double pa, double pe, double theta,
                  bool is_orbiting) const override;

    void release() override;

    bool is_ad_eng() const override;
    bool is_liquid() const override;

    bool is_released() const override;

    double get_pression() const override;

private:

    // Computes regression rate: r_dot = a * p_c^n
    double regression_rate() const;

    // Computes propellant mass generation rate [kg/s]
    double mass_flow_rate() const;

    // Computes exhaust velocity from isentropic expansion [m/s]
    double exhaust_velocity(double p_e) const;
};



// ============================================================================
// ADVANCED LIQUID ROCKET ENGINE
// ============================================================================
// High-fidelity liquid propulsion model including:
// - Characteristic velocity formulation
// - Pump-controlled chamber pressure
// - Isentropic nozzle expansion
//
class Ad_liquid_engine final : public Engine {

    // Chamber state
    double p_c_{15.0e6};    // Chamber pressure [Pa]
    double T_c_{3600.0};    // Chamber temperature [K]
    double gamma_{1.22};    
    double M_{0.022};      // Effective molar mass [kg/mol]

    // Nozzle geometry
    double A_t_{0.8};
    double A_e_{12.0};

    // Performance parameter
    double c_star_{1650.0}; // Characteristic velocity [m/s]

    bool released_{false};
    bool liquid_{true}; 

public:
    Ad_liquid_engine() = default;
    Ad_liquid_engine(double p_c, double T_c, double A_t, double A_e);

    double delta_m(double time, bool is_orbiting) const override;

    Vec eng_force(double pa, double pe, double theta,
                  bool is_orbiting) const override;

    void release() override;

    bool is_ad_eng() const override;
    bool is_liquid() const override;

    bool is_released() const override;

    double get_pression() const override;

private:

    // Mass flow determined by chamber pressure and throat area
    double mass_flow_rate() const;

    // Exhaust velocity from isentropic relation
    double exhaust_velocity(double p_e) const;

    // Thrust computation
    double thrust(double p_e, double p_a) const;
};

} // namespace engine

#endif
